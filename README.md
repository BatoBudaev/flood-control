## Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет
больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее
  хранилище данных. Допустимо использовать любое на ваше усмотрение.

## Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.  
Когда завершите задачу, в этом README опишите свой ход мыслей: как вы пришли к решению, какие были варианты и почему
выбрали именно этот.

## Решение

Первое, с чем пришлось столкнуться, это понять как работает `Context`. Изначально использовал context.WithValue для
передачи N и K. Потом от этой идеи отказался, и добавил отмену операции `Check` через `Context`.

````
select {
	case <-ctx.Done():
		return false, ctx.Err()
	default:
}
````

Для кэширование данных выбор был между **Memcached** и **Redis**. Для данной задачи, без сложного кэширования, из-за
простоты и быстроты был выбран **Memcached**.  
В хэш-таблице хранятся уникальный ключ и счётчик сообщений.

````
key := "floodControl_user:" + strconv.FormatInt(userID, 10)
count, err := m.getCount(key)
````

Далее, в той же функции `Check`, если `count` меньше заданного `K`, то либо создаем ключ, либо его инкрементируем. Иначе
выводим ошибку.

````
if count < m.K {
	if count == 0 {
		_, err := m.setItem(key, 1)
		if err != nil {
			return false, err
		}
	} else {
		_, err := m.client.Increment(key, 1)
		if err != nil {
			return false, err
		}
	}
} else {
	return false, errors.New("flood")
}
````  

В конфиге хранятся адрес сервера **Memcached**, интервал времени и максимальное число запросов.

````
server: localhost:11211
interval: 5s
max_requests: 3
````